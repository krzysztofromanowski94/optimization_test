#include <cmath>
#include <random>
#include <utility>
#include <algorithm>

#include <chrono>
#include <cstdlib>
#include <iostream>

// To find a status with lower energy according to the given condition
template<typename status, typename count, typename energy_function, typename temperature_function, typename next_function, typename generator>
status simulated_annealing(status i_old, count c, const energy_function& ef, const temperature_function& tf, const next_function& nf, generator& g){

    auto   e_old  = ef(i_old);

    status i_best = i_old;
    auto   e_best = e_old;

    std::uniform_real_distribution<decltype(e_old)> rf(0, 1);

    for(; c > 0; --c){
        status i_new = nf(i_old, g);
        auto   e_new = ef(i_new);

        if(e_new < e_best){
            i_best =           i_new ;
            e_best =           e_new ;
        }

        if( e_new < e_old || std::exp( (e_old - e_new) / tf(c) ) > rf(g) ){
            i_old  = std::move(i_new);
            e_old  = std::move(e_new);
        }
    }
    return(i_best);
}




template<typename Clock = std::chrono::system_clock>
class timer{
private:
    typedef std::chrono::time_point<Clock> time_point;
    time_point _start;
    time_point _finish;
public:
    void start(){
        _start = Clock::now();
    }
    void finish(){
        _finish = Clock::now();
    }
    template<typename rtype>
    rtype count(){
        std::chrono::duration<rtype> elapsed = _finish - _start;
        return elapsed.count();
    }
};


auto ef = [](long double x){
    return std::abs( (x - 10)*(x + 20)*(x - 30) );
};

auto tf = [](long double k){
    return std::exp( -20 * k );
};

template<typename generator>
long double nf(long double x, generator& g){
    std::normal_distribution<decltype(x)> d(0, 1);
    return x + d(g);
}

int main(int argc, char const *argv[])
{
    std::random_device rd;
    std::mt19937_64 g(rd());
    timer<std::chrono::high_resolution_clock> t;

    long double root   = std::atof(argv[1]);
    std::size_t count  = std::atoi(argv[2]);

    t.start();
    root = simulated_annealing(root, count, ef, tf, nf<decltype(g)>, g);
    t.finish();

    std::cout << "Result: " << root << std::endl;
    std::cout << "Time elapaed: " << t.count<double>() << '\n';

    return 0;
}
